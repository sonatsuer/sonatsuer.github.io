<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Blog of S.Süer – Schröder-Bernstein via Eilenberg-Mazur in Haskell</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="./assets/format.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <link rel="icon" href="assets/logo.png">
</head>
<body>
<div id="header">
<h1 class="title">Schröder-Bernstein via Eilenberg-Mazur in Haskell</h1>
</div>
<h2 id="some-set-theory">Some Set Theory</h2>
<p>Given finite sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, we know how to compare their sizes by looking at their cardinalities. We can say that <span class="math inline">\(A\)</span> is at least as large as <span class="math inline">\(B\)</span> if <span class="math inline">\(|A| \leq |B|\)</span> or <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are of the same size if <span class="math inline">\(|A| = |B|\)</span>. Obviously, if <span class="math inline">\(|A|\leq |B|\)</span> and <span class="math inline">\(|B|\leq |A|\)</span> then <span class="math inline">\(|A| = |B|\)</span>. One can also do this for infinite sets by developing a theory of infinite cardinalities.</p>
<p>However, there is a way to compare sets without referring to their cardinalities which works for both finite and infinite sets. Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be not necessarily finite sets. We will say that <span class="math inline">\(A\)</span> is at least as large as <span class="math inline">\(B\)</span> if there is an injective function from <span class="math inline">\(A\)</span> into <span class="math inline">\(B\)</span> and denote this by <span class="math inline">\(A\lesssim B\)</span>. If there is a bijection between <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> we will say that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are of the same size and denote it by <span class="math inline">\(A\approx B\)</span>.</p>
<p>With the notations we introduced we can state the Schröder-Bernstein theorem as follows:</p>
<blockquote>
<p>If <span class="math inline">\(A\lesssim B\)</span> and <span class="math inline">\(B\lesssim A\)</span> then <span class="math inline">\(A\approx B\)</span>.</p>
</blockquote>
<p>Let us look at a simple application. We will show that <span class="math inline">\(\mathbb{R}+\mathbb{Q}\approx\mathbb{R}\)</span> where <span class="math inline">\(+\)</span> denotes disjoint union. Clearly <span class="math inline">\(\mathbb{R}\lesssim\mathbb{R}+\mathbb{Q}\)</span> because we can view <span class="math inline">\(\mathbb{R}\)</span> as a subset of <span class="math inline">\(\mathbb{R}+\mathbb{Q}\)</span>. On the other hand the function from <span class="math inline">\(\mathbb{R}+\mathbb{Q}\)</span> to <span class="math inline">\(\mathbb{R}\)</span> sending <span class="math inline">\(r\in\mathbb{R}\)</span> to <span class="math inline">\(e^r\)</span> and <span class="math inline">\(q\in\mathbb{Q}\)</span> to <span class="math inline">\(-e^q\)</span> is injective as the function <span class="math inline">\(x\mapsto e^x\)</span> is an injective function whose image is contained in <span class="math inline">\(\mathbb{R}^{&gt;0}\)</span>.</p>
<p>To appreciate the power of Schröder-Bernstein, you might look for a direct proof of <span class="math inline">\(\mathbb{R}+\mathbb{Q}\approx\mathbb{R}\)</span>. But keep in mind that Schröder-Bernstein is not a theorem of intuitionistic set theory. For instance it fails in the effective topos. Actually, due to a recent result by Pradic and Brown <a href="https://arxiv.org/pdf/1904.09193.pdf">it implies the excluded middle principle</a>. On te other hand it is a theorem of ZF, namely classical set theory without the axiom of choice.</p>
<p>So how can we implement it in Haskell if it is not constructive? Well, the implementation will not be total in some cases but we will still be able to derive some interesting bijections between types from injections.</p>
<h2 id="eilenberg-mazur-swindle">Eilenberg-Mazur Swindle</h2>
<p>We haven’t talked about a proof yet. There are several proofs using several different ideas: Knaster-Tarski fixed point theorem, König’s bipartite graph argument, Cantor’s use of industrial strength cardinal arithmetic, etc. We will use a form of the <a href="https://en.wikipedia.org/wiki/Eilenberg%E2%80%93Mazur_swindle">Eilenberg-Mazur swindle</a>.</p>
Suppose <span class="math inline">\(X\lesssim Y\)</span> and <span class="math inline">\(Y\lesssim X\)</span>. Let <span class="math inline">\(A\)</span> be the complement of the image of <span class="math inline">\(Y\)</span> in <span class="math inline">\(X\)</span>. Then we have <span class="math inline">\(X\approx A + Y\)</span>. Similarly we have <span class="math inline">\(Y\approx B + X\)</span> where <span class="math inline">\(B\)</span> is the complement of the image of <span class="math inline">\(X\)</span> in <span class="math inline">\(Y\)</span>. Now this gives us, by iteration, these <span class="math display">\[
X \approx A + Y \approx A + (B + X) \approx A + (B + (A + Y)) \approx A + (B + (A + (B + X)))\approx \ldots
\]</span> If you pay attention to actual bijections, you can even write this as an infinite alternating sum plus some residual set <span class="math inline">\(C\)</span> which is not covered by any step of this process: <span class="math display">\[
X \approx A + B + A + B + \cdots + C.
\]</span> Similarly we have <span class="math display">\[
Y \approx B + A + B + A + \cdots + C.
\]</span> Note that the initial summands are different. Now we have
<span class="math display">\[\begin{align}
X &amp; \approx A + B + A + B + \cdots + C \newline
  &amp; \approx (A + B) + (A + B) + \cdots + C \newline
  &amp; \approx (B + A) + (B + A) + \cdots + C \newline
  &amp; \approx B + A + B + A + \cdots + C \newline
  &amp; \approx Y
\end{align}\]</span>
<p>Of course I pushed some details under the rug and there are a few details to be checked but nevertheless, this is a proof of the Schröder-Bernstein theorem via Eilenberg-Mazur.</p>
<h2 id="haskell-implementation">Haskell Implementation</h2>
<p>I will put code snippets together with explanations in the post. If you want to play with the code, it is available as a <a href="">gist</a>.</p>
<p>First of all, the notions of disjoint union and being in bijection already exist in Haskell but with different names. So let us first rename them so they look more like mathematical notation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">Either</span> a b
<span class="kw">type</span> a ≈ b <span class="fu">=</span> <span class="dt">Iso&#39;</span> a b</code></pre></div>
<p>Here <code class="sourceCode haskell"><span class="dt">Iso&#39;</span></code> is from the lens package. Next we will define an infinite alternating sum as a recursive data type relying on the laziness of Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AlternatingSum</span> a b
  <span class="fu">=</span> <span class="dt">FirstSummand</span> a
  <span class="fu">|</span> <span class="dt">RemainingSummands</span> (<span class="dt">AlternatingSum</span> b a)
  <span class="kw">deriving</span></code></pre></div>
<p>Our infinite sum type is related to our binary sum as expected:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">leftmostDecomposition ::</span> <span class="dt">AlternatingSum</span> a b ≈ (a <span class="fu">+</span> <span class="dt">AlternatingSum</span> b a)
leftmostDecomposition <span class="fu">=</span> iso toDecomposed fromDecomposed
  <span class="kw">where</span>
    toDecomposed <span class="fu">=</span> \<span class="kw">case</span>
      <span class="dt">FirstSummand</span> a <span class="ot">-&gt;</span> <span class="dt">Left</span> a
      <span class="dt">RemainingSummands</span> alt <span class="ot">-&gt;</span> <span class="dt">Right</span> alt
    fromDecomposed <span class="fu">=</span> either <span class="dt">FirstSummand</span> <span class="dt">RemainingSummands</span></code></pre></div>
<p>By using this decomposition twice we can obtain the grouping into binary sums in the proof above:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">associated ::</span> (a <span class="fu">+</span> (b <span class="fu">+</span> c)) ≈ ((a <span class="fu">+</span> b) <span class="fu">+</span> c)
associated <span class="fu">=</span> iso toLeftBracket fromLeftBracket
  <span class="kw">where</span>
    toLeftBracket <span class="fu">=</span> either (<span class="dt">Left</span> <span class="fu">.</span> <span class="dt">Left</span>) (either (<span class="dt">Left</span> <span class="fu">.</span> <span class="dt">Right</span>) <span class="dt">Right</span>)
    fromLeftBracket <span class="fu">=</span> either (fmap <span class="dt">Left</span>) (<span class="dt">Right</span> <span class="fu">.</span> <span class="dt">Right</span>)

<span class="ot">selfSimilarDecomposition ::</span> <span class="dt">AlternatingSum</span> a b ≈ ((a <span class="fu">+</span> b) <span class="fu">+</span> <span class="dt">AlternatingSum</span> a b)
selfSimilarDecomposition <span class="fu">=</span>
  leftmostDecomposition <span class="fu">.</span> seconding leftmostDecomposition <span class="fu">.</span> associated</code></pre></div>
<p>At this point we have everything we need to perform the infinite swap of te binary sums. One might think –I certainly did– that the following implementation works:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">infiniteSwapped ::</span> <span class="dt">AlternatingSum</span> a b ≈ <span class="dt">AlternatingSum</span> b a
infiniteSwapped <span class="fu">=</span>
  selfSimilarDecomposition <span class="fu">.</span>
  bimapping swapped infiniteSwapped <span class="fu">.</span>
  from selfSimilarDecomposition</code></pre></div>
<p>But it turns out that this is not lazy enough and it hangs. So we will use the following function which is enough for our purpose:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">infiniteSwap ::</span> forall a b<span class="fu">.</span> <span class="dt">AlternatingSum</span> a b <span class="ot">-&gt;</span> <span class="dt">AlternatingSum</span> b a
infiniteSwap <span class="fu">=</span>
  view (from selfSimilarDecomposition) <span class="fu">.</span>
  bimap (view swapped) infiniteSwap <span class="fu">.</span>
  view selfSimilarDecomposition</code></pre></div>
<p>And here is a translation of the Eilenberg-Mazur argument into Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">schroderBernsteinExplicitSum ::</span> forall a b x y<span class="fu">.</span>
  x ≈ (a <span class="fu">+</span> y) <span class="ot">-&gt;</span> y ≈ (b <span class="fu">+</span> x) <span class="ot">-&gt;</span> x ≈ y
schroderBernsteinExplicitSum xToAplusY yToBplusX <span class="fu">=</span> iso xToY yToX
  <span class="kw">where</span>
    xToY <span class="fu">=</span> contractToY <span class="fu">.</span> infiniteSwap <span class="fu">.</span> expandFromX
    yToX <span class="fu">=</span> contractToX <span class="fu">.</span> infiniteSwap <span class="fu">.</span> expandFromY

<span class="ot">    expandFromX ::</span> x <span class="ot">-&gt;</span> <span class="dt">AlternatingSum</span> a b
    expandFromX x <span class="fu">=</span> <span class="kw">case</span> x <span class="fu">^.</span> xToAplusY <span class="kw">of</span>
      <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">FirstSummand</span> a
      <span class="dt">Right</span> y <span class="ot">-&gt;</span> <span class="dt">RemainingSummands</span> <span class="fu">$</span> expandFromY y

<span class="ot">    expandFromY ::</span> y <span class="ot">-&gt;</span> <span class="dt">AlternatingSum</span> b a
    expandFromY y <span class="fu">=</span> <span class="kw">case</span> y <span class="fu">^.</span> yToBplusX <span class="kw">of</span>
      <span class="dt">Left</span> b <span class="ot">-&gt;</span> <span class="dt">FirstSummand</span> b
      <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="dt">RemainingSummands</span> <span class="fu">$</span> expandFromX x

<span class="ot">    contractToY ::</span> <span class="dt">AlternatingSum</span> b a <span class="ot">-&gt;</span> y
    contractToY <span class="fu">=</span> \<span class="kw">case</span>
      <span class="dt">FirstSummand</span> b <span class="ot">-&gt;</span> <span class="dt">Left</span> b <span class="fu">^.</span> re yToBplusX
      <span class="dt">RemainingSummands</span> alt <span class="ot">-&gt;</span> <span class="dt">Right</span> (contractToX alt) <span class="fu">^.</span> re yToBplusX

<span class="ot">    contractToX ::</span> <span class="dt">AlternatingSum</span> a b <span class="ot">-&gt;</span> x
    contractToX <span class="fu">=</span> \<span class="kw">case</span>
      <span class="dt">FirstSummand</span> a <span class="ot">-&gt;</span> <span class="dt">Left</span> a <span class="fu">^.</span> re xToAplusY
      <span class="dt">RemainingSummands</span> alt <span class="ot">-&gt;</span><span class="dt">Right</span> (contractToY alt) <span class="fu">^.</span> re xToAplusY</code></pre></div>
<p>This is good, but we will make it better. In set theory, the propositions <span class="math inline">\(X\lesssim Y\)</span> and <span class="math inline">\(\exists B. Y\approx B + X\)</span> are equivalent. But the latter is just the existential characterization of a simple prism. So the question here is can we implement Schröder-Bernstein using prisms without explicitly mentioning the complement? The answer is yes.</p>
<p>Let us first define a poor man’s existential prism.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ExistentialPrism</span> s a <span class="fu">=</span> forall c<span class="fu">.</span> <span class="dt">ExistentialPrism</span> (s ≈ (c <span class="fu">+</span> a))</code></pre></div>
<p>Now we can generalize <code class="sourceCode haskell">schroderBernsteinExplicitSum</code> to implicit sums, namely existential prisms, in a straightforward way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">schroderBernsteinExistentialPrism ::</span>
  <span class="dt">ExistentialPrism</span> x y <span class="ot">-&gt;</span> <span class="dt">ExistentialPrism</span> y x <span class="ot">-&gt;</span> x ≈ y
schroderBernsteinExistentialPrism (<span class="dt">ExistentialPrism</span> iso1) (<span class="dt">ExistentialPrism</span> iso2) <span class="fu">=</span>
  schroderBernsteinExplicitSum iso1 iso2</code></pre></div>
<p>We can turn every simple prism into a simple existential prism as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toExistential ::</span> <span class="dt">Prism&#39;</span> s a <span class="ot">-&gt;</span> <span class="dt">ExistentialPrism</span> s a
toExistential p <span class="fu">=</span> <span class="dt">ExistentialPrism</span> (iso fromS toS)
  <span class="kw">where</span>
    fromS <span class="fu">=</span> matching p
    toS <span class="fu">=</span> either id (review p)</code></pre></div>
<p>Something may look fishy here. Note that the complement we chose here is <code class="sourceCode haskell">s</code> but it should be a refinement of <code class="sourceCode haskell">s</code> where the refining predicate says “not in the image of <code class="sourceCode haskell">review p</code>”. But it is OK because, in effect, this function is acting like a smart constructor. We are not accessing arbitrary elements of <code class="sourceCode haskell">s</code>.</p>
<p>Now we have everything we need to implement Schröder-Bernstein for prisms but before that we will define one more type synonym to mimic the mathematical notation. The functions after the synonym are not needed to prove the Schröder-Bernstein theorem but they motivate the choice of notation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> a ≲ b <span class="fu">=</span> <span class="dt">Prism&#39;</span> b a

<span class="ot">reflexivity ::</span> a ≲ a
reflexivity <span class="fu">=</span> prism&#39; id <span class="dt">Just</span>

<span class="ot">transitivity ::</span> a ≲ b <span class="ot">-&gt;</span> b ≲ c <span class="ot">-&gt;</span> a ≲ c
transitivity p1 p2 <span class="fu">=</span> p2 <span class="fu">.</span> p1</code></pre></div>
<p>Finally, Schröder-Bernstein for prisms, which, in the light of the last two functions, could as well be called <code class="sourceCode haskell">antisymmetry</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">schroderBernstein ::</span> y ≲ x <span class="ot">-&gt;</span> x ≲ y <span class="ot">-&gt;</span> x ≈ y
schroderBernstein p1 p2 <span class="fu">=</span>
  schroderBernsteinExistentialPrism (toExistential p1) (toExistential p2)</code></pre></div>
<h2 id="examples">Examples</h2>
<p>Let’s look at a few examples. Unfortunately this part is going to be slightly anticlimactic. First a few prisms.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ex1 ::</span> <span class="dt">Prism&#39;</span> <span class="dt">Natural</span> <span class="dt">Natural</span>
ex1 <span class="fu">=</span> prism&#39; create mbRecover
  <span class="kw">where</span>
    create <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>)
    mbRecover n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Just</span> (n <span class="fu">-</span> <span class="dv">1</span>) <span class="kw">else</span> <span class="dt">Nothing</span>

<span class="ot">ex2 ::</span> <span class="dt">Prism&#39;</span> <span class="dt">Natural</span> <span class="dt">Natural</span>
ex2 <span class="fu">=</span> reflexivity

<span class="ot">ex3 ::</span> <span class="dt">Prism&#39;</span> <span class="dt">Natural</span> (<span class="dt">Natural</span> <span class="fu">+</span> <span class="dt">Natural</span>)
ex3 <span class="fu">=</span> prism&#39; create mbRecover
  <span class="kw">where</span>
    create <span class="fu">=</span> \<span class="kw">case</span>
      <span class="dt">Left</span> n <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="fu">*</span> n
      <span class="dt">Right</span> n <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="fu">*</span> n <span class="fu">+</span> <span class="dv">1</span>
    mbRecover n <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span>
      <span class="kw">if</span> even n <span class="kw">then</span> <span class="dt">Left</span> (n <span class="ot">`div`</span> <span class="dv">2</span>) <span class="kw">else</span> <span class="dt">Right</span> ((n <span class="fu">-</span> <span class="dv">1</span>) <span class="ot">`div`</span> <span class="dv">2</span>)

<span class="ot">ex4 ::</span> <span class="dt">Prism&#39;</span> <span class="dt">Natural</span> (<span class="dt">Natural</span> <span class="fu">+</span> <span class="dt">Natural</span>)
ex4 <span class="fu">=</span> prism&#39; create mbRecover
  <span class="kw">where</span>
    create <span class="fu">=</span> \<span class="kw">case</span>
      <span class="dt">Left</span> n <span class="ot">-&gt;</span> <span class="dv">3</span> <span class="fu">*</span> n
      <span class="dt">Right</span> n <span class="ot">-&gt;</span> <span class="dv">3</span> <span class="fu">*</span> n <span class="fu">+</span> <span class="dv">1</span>
    mbRecover n
      <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span>
        <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Left</span> <span class="fu">$</span> n <span class="ot">`div`</span> <span class="dv">3</span>
      <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">1</span>
        <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Right</span> <span class="fu">$</span> (n <span class="fu">-</span> <span class="dv">1</span>) <span class="ot">`div`</span> <span class="dv">3</span>
      <span class="fu">|</span> otherwise
        <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>We also need a function to display the graphs of functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">graphOf ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [(a, b)]
graphOf f as <span class="fu">=</span> [ (a, f a) <span class="fu">|</span> a <span class="ot">&lt;-</span> as]</code></pre></div>
<p>Here are a few examples presented as doctests.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- &gt;&gt;&gt; graphOf (view $ schroderBernstein ex1 ex1) [0..9]</span>
<span class="co">-- [(0,1),(1,0),(2,3),(3,2),(4,5),(5,4),(6,7),(7,6),(8,9),(9,8)]</span>

<span class="co">-- &gt;&gt;&gt; graphOf (view $ schroderBernstein ex1 ex2) [0..9]</span>
<span class="co">-- [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)]</span>

<span class="co">-- &gt;&gt;&gt; graphOf (view $ schroderBernstein ex3 _Right) [0..20]</span>
<span class="co">-- [(0,Left 0),(1,Right 0),(2,Left 1),(3,Right 1),(4,Left 2),(5,Right 2),(6,Left 3),(7,Right 3),(8,Left 4),(9,Right 4),(10,Left 5),(11,Right 5),(12,Left 6),(13,Right 6),(14,Left 7),(15,Right 7),(16,Left 8),(17,Right 8),(18,Left 9),(19,Right 9),(20,Left 10)]</span>

<span class="co">-- &gt;&gt;&gt; graphOf (view $ schroderBernstein ex4 _Right) [0..20]</span>
<span class="co">-- [(0,Left 0),(1,Right 0),(2,Right 2),(3,Left 1),(4,Right 1),(5,Right 5),(6,Left 2),(7,Right 7),(8,Right 8),(9,Left 3),(10,Right 3),(11,Right 11),(12,Left 4),(13,Right 4),(14,Right 14),(15,Left 5),(16,Right 16),(17,Right 17),(18,Left 6),(19,Right 6),(20,Right 20)]</span>

<span class="co">-- &gt;&gt;&gt; graphOf (view $ schroderBernstein _Right ex3) (concatMap (\x -&gt; [Left x, Right x]) [0..9])</span>
<span class="co">-- [(Left 0,0),(Right 0,1),(Left 1,2),(Right 1,3),(Left 2,4),(Right 2,5),(Left 3,6),(Right 3,7),(Left 4,8),(Right 4,9),(Left 5,10),(Right 5,11),(Left 6,12),(Right 6,13),(Left 7,14),(Right 7,15),(Left 8,16),(Right 8,17),(Left 9,18),(Right 9,19)]</span></code></pre></div>
<p>Note that we did not try all possible combinations. For instance <code class="sourceCode haskell">schroderBernstein ex2 ex1</code> hangs. As we mentioned in the very beginning, <code class="sourceCode haskell">schroderBernstein p1 p2</code> is going to be partial for some prisms <code class="sourceCode haskell">p1</code> and <code class="sourceCode haskell">p2</code>. As an exercise you can characterize the prism pairs which give total functions.</p>
<p>That’s it? Well, kind of it is. This was mostly a nerd-snipe without a concrete application in mind. Though it is possible to view <code class="sourceCode haskell">schroderBernstein</code> as a solution to a matching problem. First let us make a small observation. Suppose we have injective functions <span class="math inline">\(f\colon A\to B\)</span> and <span class="math inline">\(g\colon B\to A\)</span>. Then, by Schröder-Bernstein there is a bijection <span class="math inline">\(\sigma\colon A\to B\)</span>. By going over the construction, it is easy to see that for any <span class="math inline">\((a,b)\in A\times B\)</span> in the graph of <span class="math inline">\(\sigma\)</span>, either <span class="math inline">\(f(a) = b\)</span> or <span class="math inline">\(g(b) = a\)</span>. So if we interpret <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> as preferred match functions, then the Schröder-Bernstein theorem says that it is possible match everyone from <span class="math inline">\(A\)</span> with everyone from <span class="math inline">\(B\)</span> in such a way that in each couple, at least one side achieves preferred match.</p>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  </head>
  <body>
    <div id="footer">
      <hr>
      2018-maxBound <a href="index.html">Sonat Süer</a>
    </div>
  </body>
</html>
</body>
</html>
