<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Blog of S.Süer – Optics and Representable Functors</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="./assets/format.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <link rel="icon" href="assets/logo.png">
</head>
<body>
<div id="header">
<h1 class="title">Optics and Representable Functors</h1>
</div>
<h2 id="a-few-simple-observations">A Few Simple Observations</h2>
<p>I like the existential representations of optics because they are conceptually illuminating and allow me to play with the definitions easily without worrying about implementation details too much. This whole post is about such a playful act about the interaction between optics and representable functors.</p>
<p>My notation in this section will be a mixture of classical mathematical notation, Haskell syntax and optic names as used in, say the <a href="https://hackage.haskell.org/package/lens">lens library</a>. If it it too mathy for your taste you can skip this section and move onto implementations in Haskell. Also there is a <a href="https://gist.github.com/sonatsuer/c8fad6612a67831b745217bcf59325f0">gist</a> with all the code here plus some extra examples.</p>
<p>Suppose <span class="math inline">\(r_1\)</span> and <span class="math inline">\(r_2\)</span> are sets –or types, if you prefer– representing functors <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span>, respectively. That is, <span class="math inline">\(F(a)=a^{r_1}\)</span> and <span class="math inline">\(G(a)=a^{r_2}\)</span>. Let <span class="math inline">\(\cong\)</span> denote isomorphism. Then we have the following constructions:</p>
<p><strong>Isomorphism from isomorphism:</strong> Suppose we have an <span class="math inline">\({\rm Iso&#39;}\,r_1\, r_2 = r_1\cong r_2\)</span>. Then <span class="math display">\[
F(a) \cong a^{r_1} \cong a^{r_2} \cong G(a)
\]</span> This gives an <span class="math inline">\({\rm Iso&#39;}\,F(a)\,G(a)\)</span>.</p>
<p><strong>Lens from prism:</strong> Suppose we have a <span class="math inline">\({\rm Prism&#39;}\,r_1\, r_2 = \exists r. r_1 \cong r + r_2\)</span>. Then <span class="math display">\[
F(a) \cong a^{r_1} \cong \exists r.a^{r + r_2}\cong \exists b. a^r \times a^{r_2} \cong \exists r. a^r \times G (a)
\]</span> This gives a <span class="math inline">\({\rm Lens&#39;}\,F(a)\,G(a)\)</span>.</p>
<p><strong>Grate from lens:</strong> Suppose we have a lens <span class="math inline">\({\rm Lens&#39;}\,r_1\, r_2 = \exists r. r_1 \cong r\times r_2\)</span>. <span class="math display">\[
F(a) \cong a^{r_1} \cong \exists r. a^{r \times r_2} \cong \exists r. {a^{r_2}}^r \cong \exists r. G (a) ^r
\]</span> This gives a <span class="math inline">\({\rm Grate&#39;}\,F(a)\,G(a)\)</span>.</p>
<p>Now let us implement these constructions in Haskell!</p>
<h2 id="isomorphism-from-isomorphism">Isomorphism from Isomorphism</h2>
<p>This one is kind of free and it is not really about representable functor. Still, for the sake of completeness, I will put it here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">transportIso ::</span>
  ( <span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r1
  , <span class="dt">Rep.Representable</span> g, <span class="dt">Rep.Rep</span> g <span class="fu">~</span> r2
  ) <span class="ot">=&gt;</span>
  <span class="dt">Iso&#39;</span> r1 r2 <span class="ot">-&gt;</span> <span class="dt">Iso</span> (f a) (f b) (g a) (g b)
transportIso givenIso <span class="fu">=</span> iso fromFa toFa
  <span class="kw">where</span>
    fromFa fa <span class="fu">=</span> Rep.tabulate <span class="fu">$</span> Rep.index fa <span class="fu">.</span> view (re givenIso)
    toFa ga <span class="fu">=</span> Rep.tabulate <span class="fu">$</span> Rep.index ga <span class="fu">.</span> view givenIso</code></pre></div>
<h2 id="lens-from-prism">Lens from Prism</h2>
<p>Creating a lens from a prism is not this straightforward but still easy.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">homemadeLensFromPrism ::</span>
  ( <span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r1
  , <span class="dt">Rep.Representable</span> g, <span class="dt">Rep.Rep</span> g <span class="fu">~</span> r2
  ) <span class="ot">=&gt;</span>
  <span class="dt">Prism&#39;</span> r1 r2 <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> (f a) (g a)
homemadeLensFromPrism restriction <span class="fu">=</span> lens getter setter
  <span class="kw">where</span>
    getter fa <span class="fu">=</span>
      Rep.tabulate <span class="fu">$</span> Rep.index fa <span class="fu">.</span> review restriction
    setter fa ga <span class="fu">=</span>
      Rep.tabulate <span class="fu">$</span> \r1 <span class="ot">-&gt;</span>
        <span class="kw">case</span> preview restriction r1 <span class="kw">of</span>
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> Rep.index fa r1
          <span class="dt">Just</span> r2 <span class="ot">-&gt;</span> Rep.index ga r2</code></pre></div>
<p>Note that here we obtain a simple lens. The reason is that a representable functor is a homogeneous data structure meaning that all its contents are of the same type. It is also worth mentioning that we can implement this function using the combinator <code class="sourceCode haskell">outside</code> from the lens library. However <code class="sourceCode haskell">outside</code> expects a representable profunctor and in a lot of useful cases one only has a representable functor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">repIso ::</span> (<span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r) <span class="ot">=&gt;</span> <span class="dt">Iso</span> (f a) (f b) (r <span class="ot">-&gt;</span> a) (r <span class="ot">-&gt;</span> b)
repIso <span class="fu">=</span> iso Rep.index Rep.tabulate

<span class="ot">mkLensFromPrism ::</span>
  ( <span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r1
  , <span class="dt">Rep.Representable</span> g, <span class="dt">Rep.Rep</span> g <span class="fu">~</span> r2
  ) <span class="ot">=&gt;</span>
  <span class="dt">Prism&#39;</span> r1 r2 <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> (f a) (g a)
mkLensFromPrism pr <span class="fu">=</span> repIso <span class="fu">.</span> outside pr <span class="fu">.</span> from repIso</code></pre></div>
<p>Now let us look a few simple examples. first of all, we can recover evaluation at a point as a lens view. As a bonus we also obtain the ability to change the value at a point.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">wrappedInIdentity ::</span>
  ( <span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r, <span class="dt">Eq</span> r
  ) <span class="ot">=&gt;</span>
  r <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> (f a) (<span class="dt">Identity</span> a)
wrappedInIdentity r <span class="fu">=</span>
  mkLensFromPrism <span class="fu">$</span> only r

<span class="ot">atPosition ::</span>
  ( <span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r, <span class="dt">Eq</span> r
  ) <span class="ot">=&gt;</span>
  r <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> (f a) a
atPosition r <span class="fu">=</span> wrappedInIdentity r <span class="fu">.</span> coerced</code></pre></div>
<p>This is theoretically fine but practically not that interesting. Before moving on to more practical examples I want to introduce a combinator which turns injective functions with small domains into prisms.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkPrismFromInjection ::</span>
  (<span class="dt">Ord</span> a, <span class="dt">Enum</span> b, <span class="dt">Bounded</span> b
  ) <span class="ot">=&gt;</span>
  (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Prism&#39;</span> a b
mkPrismFromInjection create <span class="fu">=</span> prism&#39; create mbRecover
  <span class="kw">where</span>
    mbRecover a <span class="fu">=</span>
      Map.lookup a <span class="fu">$</span>
        Map.fromList [(create b, b) <span class="fu">|</span> b <span class="ot">&lt;-</span> universe ]</code></pre></div>
<p>Now combining this with <code class="sourceCode haskell">mkLensFromPrism</code> we obtain the following combinator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">restrictByPositionMapping ::</span>
  ( <span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r1
  , <span class="dt">Rep.Representable</span> g, <span class="dt">Rep.Rep</span> g <span class="fu">~</span> r2
  , <span class="dt">Ord</span> r1, <span class="dt">Enum</span> r2, <span class="dt">Bounded</span> r2
  ) <span class="ot">=&gt;</span>
  g r1 <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> (f a) (g a)
restrictByPositionMapping positionMapping <span class="fu">=</span>
  mkLensFromPrism <span class="fu">$</span> mkPrismFromInjection <span class="fu">$</span> Rep.index positionMapping</code></pre></div>
<p>To see these in action, we need representable functors. So here are two examples: <code class="sourceCode haskell"><span class="dt">Triple</span></code> and <code class="sourceCode haskell"><span class="dt">WrappedStream</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Triple</span> a <span class="fu">=</span> <span class="dt">Triple</span>
  {<span class="ot"> _slot0 ::</span> a
  ,<span class="ot"> _slot1 ::</span> a
  ,<span class="ot"> _slot2 ::</span> a
  } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Distributive</span> <span class="dt">Triple</span> <span class="kw">where</span>
  distribute wrappedTriple <span class="fu">=</span> <span class="dt">Triple</span> a1 a2 a3
    <span class="kw">where</span>
      a1 <span class="fu">=</span> _slot0 <span class="fu">&lt;$&gt;</span> wrappedTriple
      a2 <span class="fu">=</span> _slot1 <span class="fu">&lt;$&gt;</span> wrappedTriple
      a3 <span class="fu">=</span> _slot2 <span class="fu">&lt;$&gt;</span> wrappedTriple

<span class="kw">data</span> <span class="dt">Slot</span> <span class="fu">=</span> <span class="dt">Slot0</span> <span class="fu">|</span> <span class="dt">Slot1</span> <span class="fu">|</span> <span class="dt">Slot2</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Rep.Representable</span> <span class="dt">Triple</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Triple</span> <span class="fu">=</span> <span class="dt">Slot</span>
  tabulate f <span class="fu">=</span>
    <span class="dt">Triple</span> (f <span class="dt">Slot0</span>) (f <span class="dt">Slot1</span>) (f <span class="dt">Slot2</span>)
  index (<span class="dt">Triple</span> s0 s1 s2) <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">Slot0</span> <span class="ot">-&gt;</span> s0
    <span class="dt">Slot1</span> <span class="ot">-&gt;</span> s1
    <span class="dt">Slot2</span> <span class="ot">-&gt;</span> s2

<span class="co">-- newtype is to mostly avoid orphan instance warnings</span>
<span class="kw">newtype</span> <span class="dt">WrappedStream</span> a <span class="fu">=</span> <span class="dt">WrappedStream</span> {<span class="ot"> getStream ::</span> <span class="dt">Str.Stream</span> a}
  <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">WrappedStream</span> a) <span class="kw">where</span>
  show <span class="fu">=</span>
    (<span class="fu">&lt;&gt;</span><span class="st">&quot; ...&quot;</span>) <span class="fu">.</span> concatMap (<span class="fu">&lt;&gt;</span><span class="st">&quot;, &quot;</span>) <span class="fu">.</span> fmap show <span class="fu">.</span> Str.take <span class="dv">20</span> <span class="fu">.</span> getStream

<span class="kw">instance</span> <span class="dt">Distributive</span> <span class="dt">WrappedStream</span> <span class="kw">where</span>
  distribute <span class="fu">=</span> <span class="dt">WrappedStream</span> <span class="fu">.</span> Str.distribute <span class="fu">.</span> fmap getStream

<span class="kw">instance</span> <span class="dt">Rep.Representable</span> <span class="dt">WrappedStream</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">WrappedStream</span> <span class="fu">=</span> <span class="dt">Natural</span>
  tabulate f <span class="fu">=</span> <span class="dt">WrappedStream</span> <span class="fu">$</span>
    Str.fromList [f n <span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">0</span> <span class="fu">..</span>]]
  index (<span class="dt">WrappedStream</span> str) n <span class="fu">=</span>
    Str.head <span class="fu">$</span> Str.drop (fromIntegral n) str

<span class="ot">example1 ::</span> <span class="dt">WrappedStream</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> <span class="dt">WrappedStream</span> <span class="fu">$</span> Str.fromList [<span class="dv">0</span> <span class="fu">..</span>]

<span class="ot">example2 ::</span> <span class="dt">WrappedStream</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> <span class="dt">WrappedStream</span> <span class="fu">$</span> Str.fromList [<span class="dv">100</span> <span class="fu">..</span>]</code></pre></div>
<p>…and a few lenses on these types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">firstThree ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">WrappedStream</span> a) (<span class="dt">Triple</span> a)
firstThree <span class="fu">=</span> restrictByPositionMapping <span class="fu">$</span> <span class="dt">Triple</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>

<span class="ot">secondThree ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">WrappedStream</span> a) (<span class="dt">Triple</span> a)
secondThree <span class="fu">=</span> restrictByPositionMapping <span class="fu">$</span> <span class="dt">Triple</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>

<span class="ot">evens ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">WrappedStream</span> a) (<span class="dt">WrappedStream</span> a)
evens <span class="fu">=</span> mkLensFromPrism <span class="fu">$</span> prism&#39; create mbRecover
  <span class="kw">where</span>
    create n <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> n
    mbRecover n <span class="fu">=</span> <span class="kw">if</span> even n <span class="kw">then</span> <span class="dt">Just</span> (n <span class="ot">`div`</span> <span class="dv">2</span>) <span class="kw">else</span> <span class="dt">Nothing</span></code></pre></div>
<p>Finally our combinators in actions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- &gt;&gt;&gt; example1</span>
<span class="co">-- 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 ^. atPosition 5</span>
<span class="co">-- 5</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; atPosition 5 .~ 77</span>
<span class="co">-- 0, 1, 2, 3, 4, 77, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 ^. firstThree</span>
<span class="co">-- Triple {_slot0 = 0, _slot1 = 1, _slot2 = 2}</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; atPosition 4 .~ 0 &amp; view secondThree</span>
<span class="co">-- Triple {_slot0 = 3, _slot1 = 0, _slot2 = 5}</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; firstThree .~ Triple 100 101 102</span>
<span class="co">-- 100, 101, 102, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; firstThree . atPosition Slot2 .~ 999</span>
<span class="co">-- 0, 1, 999, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  ...</span>

<span class="co">-- &gt;&gt;&gt; example2</span>
<span class="co">-- 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 ^. evens</span>
<span class="co">-- 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; evens .~ example2</span>
<span class="co">-- 100, 1, 101, 3, 102, 5, 103, 7, 104, 9, 105, 11, 106, 13, 107, 15, 108, 17, 109, 19,  ...</span>

<span class="co">-- &gt;&gt;&gt; example2 &amp; evens .~ example1</span>
<span class="co">-- 0, 101, 1, 103, 2, 105, 3, 107, 4, 109, 5, 111, 6, 113, 7, 115, 8, 117, 9, 119,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; evens . evens . evens .~ example2</span>
<span class="co">-- 100, 1, 2, 3, 4, 5, 6, 7, 101, 9, 10, 11, 12, 13, 14, 15, 102, 17, 18, 19,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; evens . firstThree .~ Triple 100 101 102</span>
<span class="co">-- 100, 1, 101, 3, 102, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  ...</span>

<span class="co">-- &gt;&gt;&gt; example1 &amp; evens . secondThree . atPosition Slot2 .~ 1000</span>
<span class="co">-- 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1000, 11, 12, 13, 14, 15, 16, 17, 18, 19,  ...</span></code></pre></div>
<p>There is also an example of a <a href="https://en.wikipedia.org/wiki/Menger_sponge">2D Menger sponge</a> in the <a href="https://gist.github.com/sonatsuer/c8fad6612a67831b745217bcf59325f0#file-lensesonrepresentables-hs-L205">gist</a> implemented using <code class="sourceCode haskell">mkLensFromPrism</code>.</p>
<h2 id="grate-from-lens">Grate from Lens</h2>
<p>Grates are not popular optics. The lens library does not have them. So I will work with a grate representation and derive their basic properties here. Historically, the idea of a lens comes from profunctor optics. Grates are the optics <a href="https://r6research.livejournal.com/28050.html">corresponding to closed profunctors</a>. Their existential representation is given by this isomorphism: <span class="math display">\[
Grate&#39;\,s\, a = \exists i. s \cong a^i.
\]</span> So grates are essentially representable functors where you are not allowed to mention the representing object directly. The standard API we obtain after eliminating the existential quantifier of grates is a little mysterious. I will be working with this API. If you are curious you can have a look at <a href="https://oleg.fi/gists/posts/2018-12-12-find-correct-laws.html#grate">this</a> discussion about the grate API and the corresponding laws.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">GrateRep</span> s t a b <span class="fu">=</span> <span class="dt">GrateRep</span> {<span class="ot"> unGrateRep ::</span> ((s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t }

<span class="kw">type</span> <span class="dt">GrateRep&#39;</span> s a <span class="fu">=</span> <span class="dt">GrateRep</span> s s a a</code></pre></div>
<p>To obtain some intuition about <code>GrateRep</code>.{.haskell} let us see what we can do with it. First of all, as the existential representation suggests, every representable functor should give rise to a grate. Here is the implementation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">represented ::</span> <span class="dt">Rep.Representable</span> f <span class="ot">=&gt;</span> <span class="dt">GrateRep</span> (f a) (f b) a b
represented <span class="fu">=</span> <span class="dt">GrateRep</span> <span class="fu">$</span>
  \faab <span class="ot">-&gt;</span> Rep.tabulate (\r <span class="ot">-&gt;</span> faab (<span class="ot">`Rep.index`</span> r))</code></pre></div>
<p>Actually more is true. The <code class="sourceCode haskell"><span class="dt">Distributive</span></code> class is essentially a Haskell-98 way of talking about representables without the representing object. So can we make a grate out of a <code class="sourceCode haskell"><span class="dt">Distributive</span></code> functor? Yes! One can also give a direct implementation but I will introduce double continuation as an auxiliary type to decompose <code class="sourceCode haskell"><span class="dt">GrateRep</span></code> into meaningful pieces.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">DoubleCont</span> a b s <span class="fu">=</span> <span class="dt">DoubleCont</span> {<span class="ot"> unDoubleCont ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b }
  <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="ot">distributed ::</span> <span class="dt">Distributive</span> f <span class="ot">=&gt;</span> <span class="dt">GrateRep</span> (f a) (f b) a b
distributed <span class="fu">=</span> <span class="dt">GrateRep</span> <span class="fu">$</span>
  \faab <span class="ot">-&gt;</span> (<span class="fu">$</span> id) <span class="fu">.</span> unDoubleCont <span class="fu">&lt;$&gt;</span> distribute (<span class="dt">DoubleCont</span> faab)</code></pre></div>
<p>Note the functor instance for <code class="sourceCode haskell"><span class="dt">Doublecont</span></code> made it easier to implement the grate.</p>
<p>Ok so we have a grate, what can we do with it? To paraphrase: If you have a homogeneous container with fixed shape, what can you do with it without referring to its shape? As a trivial example, we can set all the values in te container to a fixed value. Or, more generally, we can apply the same function to all values. Maybe more interestingly, if we have two containers of the same shape we can zip them! None of these operations refer to the shape of the container, and they all can be implemented using the grate API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">zipWith0 ::</span> <span class="dt">GrateRep</span> s t a b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t
zipWith0 (<span class="dt">GrateRep</span> sabt) b <span class="fu">=</span>
  sabt (const b)

<span class="ot">zipWith1 ::</span> <span class="dt">GrateRep</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t
zipWith1 (<span class="dt">GrateRep</span> sabt) ab s <span class="fu">=</span>
  sabt <span class="fu">$</span> \sa <span class="ot">-&gt;</span> ab (sa s)

<span class="ot">zipWith2 ::</span> <span class="dt">GrateRep</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t
zipWith2 (<span class="dt">GrateRep</span> sabt) o s1 s2 <span class="fu">=</span>
  sabt <span class="fu">$</span> \sa <span class="ot">-&gt;</span> o (sa s1) (sa s2)</code></pre></div>
<p>I hope these examples give some insight about grates. Now back to our original goal: To obtain a grate from a lens. I will use functor (and contravariant) instances with respect all variables in the double continuation. However, instead of defining different newtypes around the double continuation function and define the corresponding instances I will do it in a single function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modifyDoubleCont ::</span>
  (s1 <span class="ot">-&gt;</span> s2) <span class="ot">-&gt;</span>
  (a2 <span class="ot">-&gt;</span> a1) <span class="ot">-&gt;</span>
  (b1 <span class="ot">-&gt;</span> b2) <span class="ot">-&gt;</span>
  ((s1 <span class="ot">-&gt;</span> a1) <span class="ot">-&gt;</span> b1) <span class="ot">-&gt;</span>
  ((s2 <span class="ot">-&gt;</span> a2) <span class="ot">-&gt;</span> b2)
modifyDoubleCont mapS contramapA mapB  <span class="fu">=</span>
  (<span class="fu">.</span> (contramapA <span class="fu">.</span>)) <span class="fu">.</span> (mapB <span class="fu">.</span>) <span class="fu">.</span> (<span class="fu">.</span> (<span class="fu">.</span> mapS))</code></pre></div>
<p>The definition may look horrible if you are not used to this kind of functions but there is a simple algorithm to derive it and you can discover it easily.</p>
<p>And now the function <code class="sourceCode haskell">grateFromLens</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">grateFromLens ::</span>
  ( <span class="dt">Rep.Representable</span> f, <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r1
  , <span class="dt">Rep.Representable</span> g, <span class="dt">Rep.Rep</span> g <span class="fu">~</span> r2
  ) <span class="ot">=&gt;</span>
  <span class="dt">Lens&#39;</span> r1 r2 <span class="ot">-&gt;</span> <span class="dt">GrateRep</span> (f a) (f b) (g a) (g b)
grateFromLens lns <span class="fu">=</span> <span class="dt">GrateRep</span> <span class="fu">$</span> \fagaga <span class="ot">-&gt;</span>
  Rep.tabulate <span class="fu">$</span>
    \r1 <span class="ot">-&gt;</span>
      fagaga
        <span class="fu">&amp;</span> modifyDoubleCont Rep.index Rep.tabulate Rep.index
        <span class="fu">&amp;</span> modifyDoubleCont id (\r1a r2 <span class="ot">-&gt;</span> r1a <span class="fu">$</span> lns <span class="fu">.~</span> r2 <span class="fu">$</span> r1) (\r2a _ <span class="ot">-&gt;</span> r2a <span class="fu">$</span> r1 <span class="fu">^.</span> lns )
        <span class="fu">&amp;</span> (<span class="fu">$</span> id)
        <span class="fu">&amp;</span> (<span class="fu">$</span> r1)</code></pre></div>
<p>Let us see this function in action:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">decompose3 ::</span> <span class="dt">Iso&#39;</span> <span class="dt">Natural</span> (<span class="dt">Natural</span>, <span class="dt">Slot</span>)
decompose3 <span class="fu">=</span> iso fromN toN
  <span class="kw">where</span>
    fromN n <span class="fu">=</span> (n <span class="ot">`div`</span> <span class="dv">3</span>, remainderAsSlot <span class="fu">$</span> n <span class="ot">`mod`</span> <span class="dv">3</span>)
    toN (n, slot) <span class="fu">=</span>
      <span class="dv">3</span> <span class="fu">*</span> n <span class="fu">+</span> slotAsRemainder slot
    slotAsRemainder <span class="fu">=</span> \<span class="kw">case</span>
      <span class="dt">Slot0</span> <span class="ot">-&gt;</span> <span class="dv">0</span>
      <span class="dt">Slot1</span> <span class="ot">-&gt;</span> <span class="dv">1</span>
      <span class="dt">Slot2</span> <span class="ot">-&gt;</span> <span class="dv">2</span>
    remainderAsSlot n
      <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span>    <span class="fu">=</span> <span class="dt">Slot0</span>
      <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">1</span>    <span class="fu">=</span> <span class="dt">Slot1</span>
      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Slot2</span>

<span class="ot">divideBy3 ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Natural</span> <span class="dt">Natural</span>
divideBy3 <span class="fu">=</span> decompose3 <span class="fu">.</span> _1

<span class="ot">remainderBy3 ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Natural</span> <span class="dt">Slot</span>
remainderBy3 <span class="fu">=</span> decompose3 <span class="fu">.</span> _2

<span class="ot">divideBy3Grate ::</span> <span class="dt">GrateRep</span> (<span class="dt">WrappedStream</span> a) (<span class="dt">WrappedStream</span> b) (<span class="dt">WrappedStream</span> a) (<span class="dt">WrappedStream</span> b)
divideBy3Grate <span class="fu">=</span> grateFromLens divideBy3

<span class="ot">remainderBy3Grate ::</span> <span class="dt">GrateRep</span> (<span class="dt">WrappedStream</span> a) (<span class="dt">WrappedStream</span> b) (<span class="dt">Triple</span> a) (<span class="dt">Triple</span> b)
remainderBy3Grate <span class="fu">=</span> grateFromLens remainderBy3

<span class="co">-- first three examples give you the usual zip.</span>
<span class="co">-- &gt;&gt;&gt; zipWith2 represented (+) example1 example2</span>
<span class="co">-- 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 divideBy3Grate (zipWith2 represented (+)) example1 example2</span>
<span class="co">-- 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 remainderBy3Grate (zipWith2 represented (+)) example1 example2</span>
<span class="co">-- 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,  ...</span>

<span class="co">-- These are more interesting</span>

<span class="ot">liftWrapped2 ::</span>
  (<span class="dt">Str.Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Str.Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Str.Stream</span> a) <span class="ot">-&gt;</span>
  <span class="dt">WrappedStream</span> a <span class="ot">-&gt;</span> <span class="dt">WrappedStream</span> a <span class="ot">-&gt;</span> <span class="dt">WrappedStream</span> a
liftWrapped2 binaryOp w1 w2 <span class="fu">=</span> <span class="dt">WrappedStream</span> <span class="fu">$</span> on binaryOp getStream w1 w2

<span class="co">-- &gt;&gt;&gt; liftWrapped2 Str.interleave example1 example2</span>
<span class="co">-- 0, 100, 1, 101, 2, 102, 3, 103, 4, 104, 5, 105, 6, 106, 7, 107, 8, 108, 9, 109,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 divideBy3Grate (liftWrapped2 Str.interleave) example1 example2</span>
<span class="co">-- 0, 1, 2, 100, 101, 102, 3, 4, 5, 103, 104, 105, 6, 7, 8, 106, 107, 108, 9, 10,  ...</span>

<span class="ot">pickAlternating ::</span> <span class="dt">Str.Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Str.Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Str.Stream</span> a
pickAlternating str1 str2 <span class="fu">=</span> Str.zip3 str1 str2 (Str.fromList [<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="fu">..</span>]) <span class="fu">&lt;&amp;&gt;</span>
  \(a, b, n) <span class="ot">-&gt;</span> <span class="kw">if</span> even n <span class="kw">then</span> a <span class="kw">else</span> b

<span class="co">-- &gt;&gt;&gt; liftWrapped2 pickAlternating example1 example2</span>
<span class="co">-- 0, 101, 2, 103, 4, 105, 6, 107, 8, 109, 10, 111, 12, 113, 14, 115, 16, 117, 18, 119,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 divideBy3Grate (liftWrapped2 pickAlternating) example1 example2</span>
<span class="co">-- 0, 1, 2, 103, 104, 105, 6, 7, 8, 109, 110, 111, 12, 13, 14, 115, 116, 117, 18, 19,  ...</span>

<span class="ot">crissCross ::</span> <span class="dt">Str.Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Str.Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Str.Stream</span> a
crissCross (<span class="dt">Str.Cons</span> _x1 (<span class="dt">Str.Cons</span> y1 rest1)) (<span class="dt">Str.Cons</span> x2 (<span class="dt">Str.Cons</span> _y2 rest2)) <span class="fu">=</span>
  y1 <span class="fu">Str.&lt;:&gt;</span> x2 <span class="fu">Str.&lt;:&gt;</span> crissCross rest1 rest2

<span class="co">-- &gt;&gt;&gt; liftWrapped2 crissCross example1 example2</span>
<span class="co">-- 1, 100, 3, 102, 5, 104, 7, 106, 9, 108, 11, 110, 13, 112, 15, 114, 17, 116, 19, 118,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 divideBy3Grate (liftWrapped2 crissCross) example1 example2</span>
<span class="co">-- 3, 4, 5, 100, 101, 102, 9, 10, 11, 106, 107, 108, 15, 16, 17, 112, 113, 114, 21, 22,  ...</span>

<span class="ot">shiftByEndo ::</span>
  ( <span class="dt">Rep.Representable</span> f
  , <span class="dt">Rep.Rep</span> f <span class="fu">~</span> r
  ) <span class="ot">=&gt;</span>
  <span class="dt">Endo</span> r <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
shiftByEndo (<span class="dt">Endo</span> endo) binaryOp fa1 <span class="fu">=</span>
  zipWith2 represented binaryOp (Rep.tabulate <span class="fu">$</span> Rep.index fa1 <span class="fu">.</span> endo)

<span class="ot">swapNeightbors ::</span> <span class="dt">Endo</span> <span class="dt">Natural</span>
swapNeightbors <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">$</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> even n <span class="kw">then</span> n <span class="fu">+</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="fu">-</span> <span class="dv">1</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 divideBy3Grate (shiftByEndo swapNeightbors (+)) example1 example2</span>
<span class="co">-- 103, 105, 107, 103, 105, 107, 115, 117, 119, 115, 117, 119, 127, 129, 131, 127, 129, 131, 139, 141,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 remainderBy3Grate (shiftByEndo (Endo id) (+)) example1 example2</span>
<span class="co">-- 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 remainderBy3Grate (shiftByEndo (Endo $ const Slot0) (+)) example1 example2</span>
<span class="co">-- 100, 101, 102, 106, 107, 108, 112, 113, 114, 118, 119, 120, 124, 125, 126, 130, 131, 132, 136, 137,  ...</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 remainderBy3Grate (shiftByEndo (Endo $ const Slot1) (+)) example1 example2</span>
<span class="co">-- 101, 102, 103, 107, 108, 109, 113, 114, 115, 119, 120, 121, 125, 126, 127, 131, 132, 133, 137, 138,  ...</span>

<span class="ot">rotateSlot ::</span> <span class="dt">Slot</span> <span class="ot">-&gt;</span> <span class="dt">Slot</span>
rotateSlot <span class="fu">=</span> \<span class="kw">case</span>
  <span class="dt">Slot0</span> <span class="ot">-&gt;</span> <span class="dt">Slot1</span>
  <span class="dt">Slot1</span> <span class="ot">-&gt;</span> <span class="dt">Slot2</span>
  <span class="dt">Slot2</span> <span class="ot">-&gt;</span> <span class="dt">Slot0</span>

<span class="co">-- &gt;&gt;&gt; zipWith2 remainderBy3Grate (shiftByEndo (Endo rotateSlot) (+)) example1 example2</span>
<span class="co">-- 101, 103, 102, 107, 109, 108, 113, 115, 114, 119, 121, 120, 125, 127, 126, 131, 133, 132, 137, 139,  ...</span></code></pre></div>
<p>I think this is enough.</p>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  </head>
  <body>
    <div id="footer">
      <hr>
      2018-maxBound <a href="index.html">Sonat Süer</a>
    </div>
  </body>
</html>
</body>
</html>
